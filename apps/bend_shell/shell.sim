element Point
  x : vector[3](float);
  u : vector[3](float);
  v : vector[3](float);
  m : float;
  fixed : bool;
  idx : int;
end

element Hinge
  theta0 : float;
  he0 : float;
  B : float;
end

element Face  
  loc_dir : matrix[3,2](float);
  precomp_w : matrix[2,3](float);
  area : float;
  Nu : float;
  E : float;
  Rho : float;
end

extern points : set{Point};
extern faces : set{Face}(points, points, points);
extern hinges: set{Hinge}(points, points, points, points);

func computeAngle(p1 : vector[3](float), p2 : vector[3](float), q1 : vector[3](float), q2 : vector[3](float)) -> theta : float
  var ev = p2 - p1;
  n1 = cross(ev, q1 - p1);
  n2 = cross(q2 - p1, ev);
  mag = norm(ev);
  ev = ev/mag;
  theta = atan2( dot( cross(n1, n2), ev ), dot(n1, n2) );
end

func computeMass(f : Face, pts : (Point*3)) -> mass : vector[points](float)
  mass(pts(0)) = 1.0/3.0*f.Rho*f.area;
  mass(pts(1)) = 1.0/3.0*f.Rho*f.area;
  mass(pts(2)) = 1.0/3.0*f.Rho*f.area;
end

func precomputeFaceQuantities(inout f : Face, pts : (Point*3)) -> mass : tensor[points](float)
 % 
 %                  |x1 y1 1|     
 %  |Wx1 Wx2 Wx3| . |x2 y2 1|  =  |1 0 0|
 %  |Wy1 Wy2 Wy3|   |x3 y3 1|     |0 1 0|
 % 
 %       W        .    Xloc    =    Id
 %       W = Id*Xloc^-1;

  var Xloc : matrix[3,3](float);
  for i in 0:3
      for j in 0:2
          Xloc(i,j) = dot(f.loc_dir(:,j),pts(i).x);
      end
      Xloc(i,2) = 1.0;
  end

  var Id : matrix[2,3](float) = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0];

  f.area = det(Xloc);
  f.precomp_w = Id*inv(Xloc);


end
  

func precomputeHingeQuantities(inout h : Hinge, pts : (Point*4) )
  h.theta0 = computeAngle(pts(0).x, pts(1).x, pts(2).x, pts(3).x);
  A1 = 0.5 * norm( cross(pts(1).x - pts(0).x, pts(2).x - pts(0).x) );
  A2 = 0.5 * norm( cross(pts(1).x - pts(0).x, pts(3).x - pts(0).x) );
  e0 = norm(pts(1).x - pts(0).x);
  h.he0 = 2.0*(A1+A2)/e0;
end


func stretchingForce(f : Face, pts : (Point*3)) -> force : vector[points](vector[3](float))
  
  var Xdef : matrix[2,3](float) = 0.0;
  for i in 0:2
      for j in 0:3
        for k in 0:3
          Xdef(i,j) = Xdef(i,j) + f.precomp_w(i,k)*pts(k).x(j);
        end
      end
  end

  var eps : vector[3](float);
  eps(0) = 0.5*(dot(Xdef(0,:),Xdef(0,:))-1.0);
  eps(1) = 0.5*(dot(Xdef(1,:),Xdef(1,:))-1.0);
  eps(2) = dot(Xdef(0,:),Xdef(1,:));
  

  var D : matrix[3,3](float) = 0.0;
  D(0,0) = 1.0;
  D(1,0) = f.Nu;
  D(0,1) = f.Nu;
  D(1,1) = 1.0;
  D(2,2) = 0.5*(1.0-f.Nu);
  D = f.E/(1.0-f.Nu*f.Nu) * D;

  var sig : vector[3](float) = D*eps;

  for i in 0:3
    force(pts(i)) = -f.area*(sig(0)*f.precomp_w(0,i)*Xdef(0,:)' + sig(1)*f.precomp_w(1,i)*Xdef(1,:)' + sig(2)*(f.precomp_w(0,i)*Xdef(1,:)' + f.precomp_w(1,i)*Xdef(0,:)'));
  end
  
end

func bendingForce(h : Hinge, pts : (Point*4)) -> force : vector[points](vector[3](float))
  curtheta = computeAngle(pts(0).x, pts(1).x, pts(2).x, pts(3).x);
  curvature = (curtheta - h.theta0)/h.he0;
  M = h.B*curvature;

  ev = pts(1).x - pts(0).x;
  t = 0.5*(dot(pts(2).x - pts(0).x, ev) + dot(pts(3).x - pts(0).x, ev))/dot(ev,ev);
  T = (pts(0).x + t*ev);
  L1 = pts(2).x - T;
  L2 = pts(3).x - T;

  cEL1 = cross(ev,L1);
  cEL2 = cross(ev,L2);

  force(pts(2)) = 0.5*M/norm(L1)*cEL1/norm(cEL1)*norm(ev);
  force(pts(3)) = 0.5*M/norm(L2)*cEL2/norm(cEL2)*norm(ev);
  force(pts(0)) = -(force(pts(2))*t + force(pts(3))*(1.0-t));
  force(pts(1)) = -(force(pts(2))*(1.0-t) + force(pts(3))*t);

end

func invMassMatrix(p : Point) -> Minv : matrix[points, points](matrix[3,3](float))
  block = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0];
  if not p.fixed
    minv = 1.0/p.m;
    mblock = block*minv;
    Minv(p,p) = mblock;
  end
end

func enforceConstraints(timeStep : float, inout p : Point)
  dist = norm(p.x);
  if (dist < 2.0)
    newpos = 2.0*p.x/dist;
    p.v = p.v + (newpos-p.x)/timeStep;
    p.x = 1.0 * newpos;
  end
end

func gravityForce(p : Point) -> force : vector[points](vector[3](float))
  if not p.fixed
    force(p) = [0.0, 0.0, -9.8]';
  end
end


export func initializeClothPhysics()
  map precomputeFaceQuantities to faces;
  m = map computeMass to faces;
  points.m = m;
  map precomputeHingeQuantities to hinges;  
end

export func main()
  timeStep = 1.0e-5;
  damping = 1.0e-3;

  for i in 0:1000
    du = timeStep * points.v;
    points.u = points.u + du;
    points.x = points.x + du;

    memb_force = map stretchingForce to faces reduce +;
    bend_force = map bendingForce to hinges reduce +;
    damp_force = - damping*points.v;
    gravity = map gravityForce to points reduce +;

    intforce = memb_force + bend_force + damp_force;
    
    Minv = map invMassMatrix to points reduce +;

    impulse = gravity + Minv * intforce;
    points.v = points.v + timeStep * impulse;
  end
end
